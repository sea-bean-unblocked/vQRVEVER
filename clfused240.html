<!-- shxyder -->
<!-- ultimate game stash file -->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0">
<title>Fused 240</title>
<style>
html,body,#canvas{margin:0;padding:0;border:0}
body{color:white;background-color:black;overflow:hidden;touch-action:none}
#canvas{display:block}
#canvas:focus{outline:none}
#status,#status-splash,#status-progress{position:absolute;left:0;right:0}
#status,#status-splash{top:0;bottom:0}
#status{background-color:#000000;display:flex;flex-direction:column;justify-content:center;align-items:center;visibility:hidden}
#status-splash{max-height:100%;max-width:100%;margin:auto}
#status-splash.show-image--false{display:none}
#status-splash.fullsize--true{height:100%;width:100%;object-fit:contain}
#status-splash.use-filter--false{image-rendering:pixelated}
#status-progress,#status-notice{display:none}
#status-progress{bottom:10%;width:50%;margin:0 auto}
#status-notice{background-color:#5b3943;border-radius:0.5rem;border:1px solid #9b3943;color:#e0e0e0;font-family:'Noto Sans','Droid Sans',Arial,sans-serif;line-height:1.3;margin:0 2rem;overflow:hidden;padding:1rem;text-align:center;z-index:1}
</style>
<link id="-gd-engine-icon" rel="icon" type="image/png" href="Fused 240.icon.png" />
</head>
<body>
<canvas id="canvas">Your browser does not support the canvas tag.</canvas>
<div id="status">
<img id="status-splash" class="show-image--false fullsize--true use-filter--true" src="Fused 240.png" alt="">
<progress id="status-progress"></progress>
<div id="status-notice"></div>
</div>
<script>
(function() {
    'use strict';
    const originalFetch = window.fetch;
    const mergedData = {}; 
    const pendingRequests = {}; 
    const hash = "5a492db2b4d7a2b409989961977f882530416920";
    const cdnBase = `https://cdn.jsdelivr.net/gh/shayderrr/portsv4@${hash}/fused240/`;

    function updateStatus(text) {
        const notice = document.getElementById('status-notice');
        const status = document.getElementById('status');
        if (notice && status) {
            status.style.visibility = 'visible';
            notice.style.display = 'block';
            notice.textContent = text;
        }
    }

    window.fetch = function(url, ...args) {
        const urlString = url.toString();
        if (urlString.includes("Fused") && (urlString.includes(".pck") || urlString.includes(".wasm"))) {
            const fileName = urlString.includes(".pck") ? "Fused 240.pck" : "Fused 240.wasm";
            if (mergedData[fileName]) {
                return Promise.resolve(new Response(mergedData[fileName]));
            }
            return new Promise((resolve) => {
                if (!pendingRequests[fileName]) pendingRequests[fileName] = [];
                pendingRequests[fileName].push(resolve);
            });
        }
        return originalFetch(url, ...args);
    };

    async function mergeFiles(baseFileName, start, end, pad) {
        const buffers = [];
        try {
            for (let i = start; i <= end; i++) {
                const partSuffix = pad ? i.toString().padStart(2, '0') : i;
                const partName = `${baseFileName}.part${partSuffix}`;
                updateStatus(`Fetching ${partName}...`);
                const partUrl = `${cdnBase}${encodeURIComponent(baseFileName)}.part${partSuffix}`;
                const response = await originalFetch(partUrl);
                if (!response.ok) throw new Error(`Failed to fetch ${partName}`);
                const data = await response.arrayBuffer();
                buffers.push(data);
            }
            const mergedBlob = new Blob(buffers, { type: 'application/octet-stream' });
            mergedData[baseFileName] = mergedBlob;
            if (pendingRequests[baseFileName]) {
                pendingRequests[baseFileName].forEach(resolve => resolve(new Response(mergedBlob)));
                delete pendingRequests[baseFileName];
            }
            return mergedBlob;
        } catch (err) {
            updateStatus(`Error: ${err.message}`);
        }
    }

    window.fileLoaderPromise = (async () => {
        await mergeFiles("Fused 240.pck", 1, 12, true);
        await mergeFiles("Fused 240.wasm", 1, 3, false);
        updateStatus("Download complete. Launching...");
    })();
})();
</script>
<script src="https://cdn.jsdelivr.net/gh/shayderrr/portsv4@5a492db2b4d7a2b409989961977f882530416920/fused240/Fused%20240.js"></script>
<script>
const GODOT_CONFIG = {"args":[],"canvasResizePolicy":2,"ensureCrossOriginIsolationHeaders":true,"executable":"Fused 240","experimentalVK":false,"fileSizes":{"Fused 240.pck":235238304,"Fused 240.wasm":52126319},"focusCanvas":true,"gdextensionLibs":[]};
const engine = new Engine(GODOT_CONFIG);
(function () {
    const statusOverlay = document.getElementById('status');
    const statusProgress = document.getElementById('status-progress');
    const statusNotice = document.getElementById('status-notice');
    let initializing = true;
    let statusMode = '';
    function setStatusMode(mode) {
        if (statusMode === mode || !initializing) return;
        if (mode === 'hidden') { statusOverlay.remove(); initializing = false; return; }
        statusOverlay.style.visibility = 'visible';
        statusProgress.style.display = mode === 'progress' ? 'block' : 'none';
        statusNotice.style.display = mode === 'notice' ? 'block' : 'none';
        statusMode = mode;
    }
    function setStatusNotice(text) {
        while (statusNotice.lastChild) statusNotice.removeChild(statusNotice.lastChild);
        text.split('\n').forEach((line) => {
            statusNotice.appendChild(document.createTextNode(line));
            statusNotice.appendChild(document.createElement('br'));
        });
    }
    function displayFailureNotice(err) {
        if (err instanceof Error) setStatusNotice(err.message);
        else if (typeof err === 'string') setStatusNotice(err);
        else setStatusNotice('An unknown error occurred.');
        setStatusMode('notice');
        initializing = false;
    }
    if (Engine.getMissingFeatures({ threads: false }).length !== 0) {
        displayFailureNotice('Error\nMissing required browser features.');
    } else {
        window.fileLoaderPromise.then(() => {
            setStatusMode('progress');
            engine.startGame({
                'onProgress': function (current, total) {
                    if (current > 0 && total > 0) {
                        statusProgress.value = current;
                        statusProgress.max = total;
                    } else {
                        statusProgress.removeAttribute('value');
                        statusProgress.removeAttribute('max');
                    }
                },
            }).then(() => {
                setStatusMode('hidden');
            }, displayFailureNotice);
        });
    }
}());
</script>
</body>
</html>